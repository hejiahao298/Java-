# JVM内存详解

-  JVM内存的划分有五片：

1. 寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制. 
2. 本地方法区；
3. 方法区：存放类的方法信息。
4. 栈内存：存放基本类型的变量数据和对象的引用。
5. 堆内存：存放所有new出来的对象。

>  当mian()方法调用某方法时，先从栈区中存放的找到对象的引用，在从引用地址找到堆区的实例对象，实例对象在从方法区中调用方法。

![63467293-de29-39cb-b3bc-eb9e06194535](C:\Users\27600\Desktop\63467293-de29-39cb-b3bc-eb9e06194535.jpg)



### **一 ，栈和堆**

> 栈与堆都是Java用来在Ram中存放数据的地方

- **栈内存**:存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

- **堆内存**:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。

### 区别：

> 栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： 

int a = 3; 
int b = 3； 
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。

要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 

### 例子：
**String**是一个特殊的包装类数据。可以用： 
String str = new String("abc"); 
String str = "abc"; 
两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。 
而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放"abc"，如果没有，则将"abc"存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。 

